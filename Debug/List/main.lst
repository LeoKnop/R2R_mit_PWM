###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          31/Jul/2024  16:51:46
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
#    Command line  =  
#        -f C:\Users\elokn\AppData\Local\Temp\EWA32C.tmp
#        (C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
#        -lC
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\List
#        -o
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430F5529__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -Ol --multiplier=32
#        --hw_workaround=CPU40 --hw_workaround=nop_after_lpm
#        --code_model=large)
#    Locale        =  German_DEU.1252
#    List file     =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\List\main.lst
#    Object file   =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\Obj\main.r43
#
###############################################################################

C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
      1          #include "msp430F5529.h"

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x21c
   \   union <unnamed> _A_PAIFG_L
   \                     _A_PAIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x222
   \   union <unnamed> _A_PBOUT_L
   \                     _A_PBOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ec
   \   unsigned char const volatile UCB0RXBUF
   \                     UCB0RXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x5ee
   \   unsigned char volatile UCB0TXBUF
   \                     UCB0TXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x5fc
   \   union <unnamed> _A_UCB0ICTL_L
   \                     _A_UCB0ICTL_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x60e
   \   unsigned char volatile UCA1TXBUF
   \                     UCA1TXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x61c
   \   union <unnamed> _A_UCA1ICTL_L
   \                     _A_UCA1ICTL_L:
   \   000000                DS8 2
      2          #include "lib/init.h"
      3          
      4          #define pwm_aufloesung 8
      5          #define filter_aufloesung 8
      6          #define r2r_aufloesung 8
      7          
      8          // Globale Variablen Deklaration

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      9          unsigned int conversioncounter = 0;     // Zeigt an wie viele Werte der ADC schon übertragen hat
   \                     conversioncounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     10          unsigned int pwm_on = 0;                // Pulsbreitenverhältniss: pwm_on/2^pwm_aufloesung
   \                     pwm_on:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     11          unsigned int pwm_anzahl = (1 << pwm_aufloesung); // Auflösung PWM (einstellbar durch k)
   \                     pwm_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for pwm_anzahl>`
     12          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     13          unsigned int r2r_ansteuerung = 0;       // legt fest welche Bits des R2R Netzwerkes gesetzt werden
   \                     r2r_ansteuerung:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     14          unsigned int r2r_anzahl = (1 << r2r_aufloesung);
   \                     r2r_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for r2r_anzahl>`
     15          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          unsigned int mittelwert = 0;
   \                     mittelwert:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     17          unsigned int mittelwert_anzahl = (1 << filter_aufloesung);
   \                     mittelwert_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for mittelwert_anzahl>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          long sum;                               // Summe zum berechnen des Mittelwerts ( muss double sein, da 8Bit * 16 Bit = 28 BIT Zahlen Adiert werden)
   \                     sum:
   \   000000                DS8 4
     19          
     20          int SPI_recieve(void);
     21          void UART_send(int two_bytes);
     22          

   \                                 In  segment CODE, align 2
     23          void main(void)
   \                     main:
     24          {
     25            // Initialisierungen
     26            initMC();
   \   000000   ........     CALLA   #initMC
     27            initPWM(pwm_anzahl, pwm_on);
   \   000004   1D42....     MOV.W   &pwm_on, R13
   \   000008   1C42....     MOV.W   &pwm_anzahl, R12
   \   00000C   ........     CALLA   #initPWM
     28            initR2R();
   \   000010   ........     CALLA   #initR2R
     29            initSPI();
   \   000014   ........     CALLA   #initSPI
     30            initUART();
   \   000018   ........     CALLA   #initUART
     31            
     32            while(1)
     33            {
     34              P4OUT |= BIT7;                      // Grüne LED leuchtet wenn das Programm bereit zum Starten ist
   \                     ??main_1:
   \   00001C   F2D080002302 BIS.B   #0x80, &0x223
     35              P1OUT &= ~BIT0;                     // RoteLED aus
   \   000022   D2C30202     BIC.B   #0x1, &0x202
     36              while(0 == P1IFG);                  // Wenn S2 gedrückt wird, startet das Prtogramm
   \                     ??main_0:
   \   000026   C2931C02     CMP.B   #0x0, &0x21c
   \   00002A   FD27         JEQ     ??main_0
     37              P1OUT |= BIT0;                      // Rote LED leuchtet wenn das Programm läuft
   \   00002C   D2D30202     BIS.B   #0x1, &0x202
     38              P4OUT &= ~BIT7;                     // Grüne LED aus
   \   000030   F2C080002302 BIC.B   #0x80, &0x223
     39              
     40              r2r_ansteuerung = 0;                // Zum Start alle "Bits" des R2R auf 0
   \   000036   8243....     MOV.W   #0x0, &r2r_ansteuerung
   \   00003A   023C         JMP     ??main_5
     41              while(r2r_ansteuerung < r2r_aufloesung)                                      // Schleife steuert jede Biteinstellung des R2R-Netzwerkes an
     42              {
     43                P6OUT = r2r_ansteuerung;
     44                pwm_on = 0;
     45                while(pwm_on < pwm_anzahl)                                                // Schleife steuert jedes Pulsbreitenverhältniss an
     46                {
     47                  mittelwert = 0;
     48                  sum = 0;
     49                  conversioncounter = 0;
     50                  while(conversioncounter < mittelwert_anzahl)                            // Schleife bildet Mittelwert
     51                  {
     52                    // Wait for SPI Interrupts
     53                    sum = sum + SPI_recieve();    // Messung durch ADC
     54                  }
     55                  mittelwert = sum >> filter_aufloesung;          // Teilen der Summe durch 256
     56                  UART_send(mittelwert);           // Über UART in csv
     57                  ++pwm_on;                       // erhöht Pulsbreite und fungiert als counter
     58                }
     59                ++r2r_ansteuerung;
   \                     ??main_3:
   \   00003C   9253....     ADD.W   #0x1, &r2r_ansteuerung
   \                     ??main_5:
   \   000040   B292....     CMP.W   #0x8, &r2r_ansteuerung
   \   000044   EB2F         JC      ??main_1
   \   000046   D242....4302 MOV.B   &r2r_ansteuerung, &0x243
   \   00004C   8243....     MOV.W   #0x0, &pwm_on
   \   000050   1F3C         JMP     ??main_6
   \                     ??main_2:
   \   000052   ........     CALLA   #SPI_recieve
   \   000056   0D4C         MOV.W   R12, R13
   \   000058   0D5D         RLA.W   R13
   \   00005A   0D7D         SUBC.W  R13, R13
   \   00005C   3DE3         XOR.W   #0xffff, R13
   \   00005E   825C....     ADD.W   R12, &sum
   \   000062   826D....     ADDC.W  R13, &sum + 2
   \                     ??main_4:
   \   000066   9292........ CMP.W   &mittelwert_anzahl, &conversioncounter
   \   00006C   F22B         JNC     ??main_2
   \   00006E   1E42....     MOV.W   &sum, R14
   \   000072   1F42....     MOV.W   &sum + 2, R15
   \   000076   8E10         SWPB    R14
   \   000078   8F10         SWPB    R15
   \   00007A   4EEF         XOR.B   R15, R14
   \   00007C   0EEF         XOR.W   R15, R14
   \   00007E   8F11         SXT     R15
   \   000080   824E....     MOV.W   R14, &mittelwert
   \   000084   1C42....     MOV.W   &mittelwert, R12
   \   000088   ........     CALLA   #UART_send
   \   00008C   9253....     ADD.W   #0x1, &pwm_on
   \                     ??main_6:
   \   000090   9292........ CMP.W   &pwm_anzahl, &pwm_on
   \   000096   D22F         JC      ??main_3
   \   000098   8243....     MOV.W   #0x0, &mittelwert
   \   00009C   8243....     MOV.W   #0x0, &sum
   \   0000A0   8243....     MOV.W   #0x0, &sum + 2
   \   0000A4   8243....     MOV.W   #0x0, &conversioncounter
   \   0000A8   DE3F         JMP     ??main_4
   \   0000AA   0343         NOP
   \   0000AC                REQUIRE _A_PBOUT_L
   \   0000AC                REQUIRE _A_PAOUT_L
   \   0000AC                REQUIRE _A_PAIFG_L
   \   0000AC                REQUIRE _A_PCOUT_L
     60              } 
     61            }
     62          }
     63          

   \                                 In  segment CODE, align 2
     64          int SPI_recieve(void)
   \                     SPI_recieve:
     65          {
     66            int msb_byte = 0;
   \   000000   0C43         MOV.W   #0x0, R12
     67            int lsb_byte = 0;
   \   000002   0E43         MOV.W   #0x0, R14
     68            
     69            UCB0TXBUF = 0;                     // 8 Flanken an Slave senden
   \   000004   C243EE05     MOV.B   #0x0, &0x5ee
     70            while((UCB0IFG & UCRXIFG) ==0);       // Auf Antwort warten
   \                     ??SPI_recieve_0:
   \   000008   D2B3FD05     BIT.B   #0x1, &0x5fd
   \   00000C   FD2B         JNC     ??SPI_recieve_0
     71            msb_byte = UCB0RXBUF;                 // Antwort in msb_byte speichern
   \   00000E   5C42EC05     MOV.B   &0x5ec, R12
   \   000012   4C4C         MOV.B   R12, R12
     72            
     73            
     74                  
     75            UCB0TXBUF = 0;                     // 8 Flanken an Slave senden
   \   000014   C243EE05     MOV.B   #0x0, &0x5ee
     76            while((UCB0IFG & UCRXIFG) == 0);       // Auf Antwort warten
   \                     ??SPI_recieve_1:
   \   000018   D2B3FD05     BIT.B   #0x1, &0x5fd
   \   00001C   FD2B         JNC     ??SPI_recieve_1
     77            lsb_byte = UCB0RXBUF;                 // Antwort in msb_byte speichern
   \   00001E   5E42EC05     MOV.B   &0x5ec, R14
   \   000022   4E4E         MOV.B   R14, R14
     78            
     79            return (msb_byte << 8 + lsb_byte);     // bytes in 16bit int zusammensetzen
   \   000024   7E52         ADD.B   #0x8, R14
   \   000026   BE000100     SUBA    #0x1, R14
   \   00002A   0230         JN      ??SPI_recieve_2
   \   00002C                RPT     R14
   \   00002C   CE180C5C     RLAX.W  R12
   \                     ??SPI_recieve_2:
   \   000030   AE000100     ADDA    #0x1, R14
   \   000034   1001         RETA
   \   000036                REQUIRE UCB0TXBUF
   \   000036                REQUIRE _A_UCB0ICTL_L
   \   000036                REQUIRE UCB0RXBUF
     80          }
     81          

   \                                 In  segment CODE, align 2
     82          void UART_send(int two_bytes)
   \                     UART_send:
     83          {
     84            char lsb_byte = two_bytes & 0x0F;
   \   000000   0E12         PUSH.W  R14
   \   000002   C14C0000     MOV.B   R12, 0(SP)
   \   000006   3E41         POP.W   R14
   \   000008   7EF00F00     AND.B   #0xf, R14
     85            char msb_byte = two_bytes >> 8;
   \   00000C   8C10         SWPB    R12
   \   00000E   8C11         SXT     R12
     86            
     87            UCA1TXBUF = msb_byte;
   \   000010   C24C0E06     MOV.B   R12, &0x60e
     88            while((UCTXIFG & UCA1IFG) == 0);
   \                     ??UART_send_0:
   \   000014   E2B31D06     BIT.B   #0x2, &0x61d
   \   000018   FD2B         JNC     ??UART_send_0
     89            UCA1TXBUF = lsb_byte;
   \   00001A   C24E0E06     MOV.B   R14, &0x60e
     90            while((UCTXIFG & UCA1IFG) == 0);
   \                     ??UART_send_1:
   \   00001E   E2B31D06     BIT.B   #0x2, &0x61d
   \   000022   FD2B         JNC     ??UART_send_1
     91            
     92          }
   \   000024   1001         RETA
   \   000026                REQUIRE UCA1TXBUF
   \   000026                REQUIRE _A_UCA1ICTL_L

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for pwm_anzahl>`:
   \   000000   0001         DC16 256

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for r2r_anzahl>`:
   \   000000   0001         DC16 256

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for mittelwert_anzahl>`:
   \   000000   0001         DC16 256

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   SPI_recieve
      6   UART_send
      4   main
        4   -> SPI_recieve
        4   -> UART_send
        4   -> initMC
        4   -> initPWM
        4   -> initR2R
        4   -> initSPI
        4   -> initUART


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for mittelwert_anzahl>
       2  ?<Initializer for pwm_anzahl>
       2  ?<Initializer for r2r_anzahl>
      54  SPI_recieve
      38  UART_send
       1  UCA1TXBUF
       1  UCB0RXBUF
       1  UCB0TXBUF
       2  _A_PAIFG_L
       2  _A_PAOUT_L
       2  _A_PBOUT_L
       2  _A_PCOUT_L
       2  _A_UCA1ICTL_L
       2  _A_UCB0ICTL_L
       2  conversioncounter
     172  main
       2  mittelwert
       2  mittelwert_anzahl
       2  pwm_anzahl
       2  pwm_on
       2  r2r_ansteuerung
       2  r2r_anzahl
       4  sum

 
 264 bytes in segment CODE
  15 bytes in segment DATA16_AN
   6 bytes in segment DATA16_I
   6 bytes in segment DATA16_ID
  12 bytes in segment DATA16_Z
 
 264 bytes of CODE  memory
   6 bytes of CONST memory
  18 bytes of DATA  memory (+ 15 bytes shared)

Errors: none
Warnings: none
