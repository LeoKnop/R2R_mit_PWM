###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          27/Jun/2024  13:46:18
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
#    Command line  =  
#        -f C:\Users\elokn\AppData\Local\Temp\EWF366.tmp
#        (C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
#        -lC
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\List
#        -o
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430F5529__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -Ol --multiplier=32
#        --hw_workaround=CPU40 --hw_workaround=nop_after_lpm
#        --code_model=large)
#    Locale        =  German_DEU.1252
#    List file     =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\List\main.lst
#    Object file   =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\Obj\main.r43
#
###############################################################################

C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
      1          #include "msp430F5529.h"

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x21c
   \   union <unnamed> _A_PAIFG_L
   \                     _A_PAIFG_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x222
   \   union <unnamed> _A_PBOUT_L
   \                     _A_PBOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x242
   \   union <unnamed> _A_PCOUT_L
   \                     _A_PCOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x60e
   \   unsigned char volatile UCA1TXBUF
   \                     UCA1TXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x61c
   \   union <unnamed> _A_UCA1ICTL_L
   \                     _A_UCA1ICTL_L:
   \   000000                DS8 2
      2          #include "lib/init.h"
      3          
      4          #define pwm_aufloesung 8
      5          #define filter_aufloesung 8
      6          #define r2r_aufloesung 8
      7          
      8          // Globale Variablen Deklaration

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
      9          unsigned int conversioncounter = 0;     // Zeigt an wie viele Werte der ADC schon übertragen hat
   \                     conversioncounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     10          unsigned int pwm_on = 0;                // Pulsbreitenverhältniss: pwm_on/2^pwm_aufloesung
   \                     pwm_on:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     11          unsigned int pwm_anzahl = (1 << pwm_aufloesung); // Auflösung PWM (einstellbar durch k)
   \                     pwm_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for pwm_anzahl>`
     12          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     13          unsigned int r2r_ansteuerung = 0;       // legt fest welche Bits des R2R Netzwerkes gesetzt werden
   \                     r2r_ansteuerung:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     14          unsigned int r2r_anzahl = (1 << r2r_aufloesung);
   \                     r2r_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for r2r_anzahl>`
     15          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     16          unsigned int mittelwert = 0;
   \                     mittelwert:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     17          unsigned int mittelwert_anzahl = (1 << filter_aufloesung);
   \                     mittelwert_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for mittelwert_anzahl>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     18          long sum;                               // Summe zum berechnen des Mittelwerts ( muss double sein, da 8Bit * 16 Bit = 28 BIT Zahlen Adiert werden)
   \                     sum:
   \   000000                DS8 4
     19          
     20          int SPI_recieve(void);
     21          void UART_send(int two_bytes);
     22          

   \                                 In  segment CODE, align 2
     23          void main(void)
   \                     main:
   \                     ??main_1:
     24          {
     25            // Initialisierungen
     26            
     27            
     28            while(1)
     29            {
     30              P4OUT |= BIT7;                      // Grüne LED leuchtet wenn das Programm bereit zum Starten ist
   \   000000   F2D080002302 BIS.B   #0x80, &0x223
     31              P1OUT &= ~BIT0;                     // RoteLED aus
   \   000006   D2C30202     BIC.B   #0x1, &0x202
     32              while(0 == P1IFG);                  // Wenn S2 gedrückt wird, startet das Prtogramm
   \                     ??main_0:
   \   00000A   C2931C02     CMP.B   #0x0, &0x21c
   \   00000E   FD27         JEQ     ??main_0
     33              P1OUT |= BIT0;                      // Rote LED leuchtet wenn das Programm läuft
   \   000010   D2D30202     BIS.B   #0x1, &0x202
     34              P4OUT &= ~BIT7;                     // Grüne LED aus
   \   000014   F2C080002302 BIC.B   #0x80, &0x223
     35              
     36              r2r_ansteuerung = 0;                // Zum Start alle "Bits" des R2R auf 0
   \   00001A   8243....     MOV.W   #0x0, &r2r_ansteuerung
   \   00001E   023C         JMP     ??main_5
     37              while(r2r_ansteuerung < r2r_aufloesung)                                      // Schleife steuert jede Biteinstellung des R2R-Netzwerkes an
     38              {
     39                P6OUT = r2r_ansteuerung;
     40                pwm_on = 0;
     41                while(pwm_on < pwm_anzahl)                                                // Schleife steuert jedes Pulsbreitenverhältniss an
     42                {
     43                  sum = 0;
     44                  conversioncounter = 0;
     45                  while(conversioncounter < mittelwert_anzahl)                            // Schleife bildet Mittelwert
     46                  {
     47                    sum = sum + SPI_recieve();    // Messung durch ADC
     48                    ++conversioncounter;
     49                  }
     50                  mittelwert = sum >> 8;          // Teilen der Summe durch 256
     51                  UART_send(mittelwert);           // Über UART in csv
     52                  ++pwm_on;                       // erhöht Pulsbreite und fungiert als counter
     53                }
     54                ++r2r_ansteuerung;
   \                     ??main_3:
   \   000020   9253....     ADD.W   #0x1, &r2r_ansteuerung
   \                     ??main_5:
   \   000024   B292....     CMP.W   #0x8, &r2r_ansteuerung
   \   000028   EB2F         JC      ??main_1
   \   00002A   D242....4302 MOV.B   &r2r_ansteuerung, &0x243
   \   000030   8243....     MOV.W   #0x0, &pwm_on
   \   000034   213C         JMP     ??main_6
   \                     ??main_2:
   \   000036   ........     CALLA   #SPI_recieve
   \   00003A   0D4C         MOV.W   R12, R13
   \   00003C   0D5D         RLA.W   R13
   \   00003E   0D7D         SUBC.W  R13, R13
   \   000040   3DE3         XOR.W   #0xffff, R13
   \   000042   825C....     ADD.W   R12, &sum
   \   000046   826D....     ADDC.W  R13, &sum + 2
   \   00004A   9253....     ADD.W   #0x1, &conversioncounter
   \                     ??main_4:
   \   00004E   9292........ CMP.W   &mittelwert_anzahl, &conversioncounter
   \   000054   F02B         JNC     ??main_2
   \   000056   1E42....     MOV.W   &sum, R14
   \   00005A   1F42....     MOV.W   &sum + 2, R15
   \   00005E   8E10         SWPB    R14
   \   000060   8F10         SWPB    R15
   \   000062   4EEF         XOR.B   R15, R14
   \   000064   0EEF         XOR.W   R15, R14
   \   000066   8F11         SXT     R15
   \   000068   824E....     MOV.W   R14, &mittelwert
   \   00006C   1C42....     MOV.W   &mittelwert, R12
   \   000070   ........     CALLA   #UART_send
   \   000074   9253....     ADD.W   #0x1, &pwm_on
   \                     ??main_6:
   \   000078   9292........ CMP.W   &pwm_anzahl, &pwm_on
   \   00007E   D02F         JC      ??main_3
   \   000080   8243....     MOV.W   #0x0, &sum
   \   000084   8243....     MOV.W   #0x0, &sum + 2
   \   000088   8243....     MOV.W   #0x0, &conversioncounter
   \   00008C   E03F         JMP     ??main_4
   \   00008E   0343         NOP
   \   000090                REQUIRE _A_PBOUT_L
   \   000090                REQUIRE _A_PAOUT_L
   \   000090                REQUIRE _A_PAIFG_L
   \   000090                REQUIRE _A_PCOUT_L
     55              } 
     56            }
     57          }
     58          
     59          

   \                                 In  segment CODE, align 2
     60          int SPI_recieve(void)
   \                     SPI_recieve:
     61          {
     62            return 0;
   \   000000   0C43         MOV.W   #0x0, R12
   \   000002   1001         RETA
     63          }
     64          

   \                                 In  segment CODE, align 2
     65          void UART_send(int two_bytes)
   \                     UART_send:
     66          {
     67            char lsb_byte = two_bytes & 0x0F;
   \   000000   0E12         PUSH.W  R14
   \   000002   C14C0000     MOV.B   R12, 0(SP)
   \   000006   3E41         POP.W   R14
   \   000008   7EF00F00     AND.B   #0xf, R14
     68            char msb_byte = two_bytes >> 8;
   \   00000C   8C10         SWPB    R12
   \   00000E   8C11         SXT     R12
     69              
     70            UCA1TXBUF = lsb_byte;
   \   000010   C24E0E06     MOV.B   R14, &0x60e
     71            while((UCTXIFG & UCA1IFG) == 0);
   \                     ??UART_send_0:
   \   000014   E2B31D06     BIT.B   #0x2, &0x61d
   \   000018   FD2B         JNC     ??UART_send_0
     72            UCA1TXBUF = msb_byte;
   \   00001A   C24C0E06     MOV.B   R12, &0x60e
     73            while((UCTXIFG & UCA1IFG) == 0);
   \                     ??UART_send_1:
   \   00001E   E2B31D06     BIT.B   #0x2, &0x61d
   \   000022   FD2B         JNC     ??UART_send_1
     74          }
   \   000024   1001         RETA
   \   000026                REQUIRE UCA1TXBUF
   \   000026                REQUIRE _A_UCA1ICTL_L

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for pwm_anzahl>`:
   \   000000   0001         DC16 256

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for r2r_anzahl>`:
   \   000000   0001         DC16 256

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for mittelwert_anzahl>`:
   \   000000   0001         DC16 256

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   SPI_recieve
      6   UART_send
      4   main
        4   -> SPI_recieve
        4   -> UART_send


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for mittelwert_anzahl>
       2  ?<Initializer for pwm_anzahl>
       2  ?<Initializer for r2r_anzahl>
       4  SPI_recieve
      38  UART_send
       1  UCA1TXBUF
       2  _A_PAIFG_L
       2  _A_PAOUT_L
       2  _A_PBOUT_L
       2  _A_PCOUT_L
       2  _A_UCA1ICTL_L
       2  conversioncounter
     144  main
       2  mittelwert
       2  mittelwert_anzahl
       2  pwm_anzahl
       2  pwm_on
       2  r2r_ansteuerung
       2  r2r_anzahl
       4  sum

 
 186 bytes in segment CODE
  11 bytes in segment DATA16_AN
   6 bytes in segment DATA16_I
   6 bytes in segment DATA16_ID
  12 bytes in segment DATA16_Z
 
 186 bytes of CODE  memory
   6 bytes of CONST memory
  18 bytes of DATA  memory (+ 11 bytes shared)

Errors: none
Warnings: none
