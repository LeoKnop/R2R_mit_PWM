###############################################################################
#
# IAR C/C++ Compiler V7.21.1.1000/W32 for MSP430          01/Aug/2024  13:00:22
# Copyright 1996-2021 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for MSP430, 8K KickStart Edition 7.21
#
#    __rt_version  =  3
#    __double_size =  32
#    __reg_r4      =  free
#    __reg_r5      =  free
#    __pic         =  no
#    __core        =  430X
#    __data_model  =  small
#    __code_model  =  large
#    Source file   =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
#    Command line  =  
#        -f C:\Users\elokn\AppData\Local\Temp\EW242F.tmp
#        (C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
#        -lC
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\List
#        -o
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa --debug
#        -D__MSP430F5529__ -e --double=32 --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.5\430\lib\dlib\dl430xlsfn.h"
#        --core=430X --data_model=small -Ol --multiplier=32
#        --hw_workaround=CPU40 --hw_workaround=nop_after_lpm
#        --code_model=large)
#    Locale        =  German_DEU.1252
#    List file     =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\List\main.lst
#    Object file   =  
#        C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\Debug\Obj\main.r43
#
###############################################################################

C:\Users\elokn\Documents\Studium\6.Sem\Untersuchung_R2R_Mittelwert_PWM\main.c
      1          #include "msp430F5529.h"

   \                                 In  segment DATA16_AN, at 0x202
   \   union <unnamed> _A_PAOUT_L
   \                     _A_PAOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x222
   \   union <unnamed> _A_PBOUT_L
   \                     _A_PBOUT_L:
   \   000000                DS8 2

   \                                 In  segment DATA16_AN, at 0x5ec
   \   unsigned char const volatile UCB0RXBUF
   \                     UCB0RXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x5ee
   \   unsigned char volatile UCB0TXBUF
   \                     UCB0TXBUF:
   \   000000                DS8 1

   \                                 In  segment DATA16_AN, at 0x5fc
   \   union <unnamed> _A_UCB0ICTL_L
   \                     _A_UCB0ICTL_L:
   \   000000                DS8 2
      2          #include "lib/init.h"
      3          #include "lib/interface.h"
      4          
      5          #define pwm_aufloesung 8
      6          #define filter_aufloesung 8
      7          #define r2r_aufloesung 8
      8          
      9          // Globale Variablen Deklaration

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     10          unsigned int conversioncounter = 0;     // Zeigt an wie viele Werte der ADC schon übertragen hat
   \                     conversioncounter:
   \   000000                DS8 2

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     11          unsigned int pwm_on = 0;                // Pulsbreitenverhältniss: pwm_on/2^pwm_aufloesung
   \                     pwm_on:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     12          unsigned int pwm_anzahl = (1 << pwm_aufloesung); // Auflösung PWM (einstellbar durch k)
   \                     pwm_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for pwm_anzahl>`
     13          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     14          unsigned int r2r_ansteuerung = 0;       // legt fest welche Bits des R2R Netzwerkes gesetzt werden
   \                     r2r_ansteuerung:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     15          unsigned int r2r_anzahl = (1 << r2r_aufloesung);
   \                     r2r_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for r2r_anzahl>`
     16          

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     17          unsigned int mittelwert = 0;
   \                     mittelwert:
   \   000000                DS8 2

   \                                 In  segment DATA16_I, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_copy
     18          unsigned int mittelwert_anzahl = (1 << filter_aufloesung);
   \                     mittelwert_anzahl:
   \   000000                DS8 2
   \   000002                REQUIRE `?<Initializer for mittelwert_anzahl>`

   \                                 In  segment DATA16_Z, align 2, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     19          long sum;                               // Summe zum berechnen des Mittelwerts ( muss double sein, da 8Bit * 16 Bit = 28 BIT Zahlen Adiert werden)
   \                     sum:
   \   000000                DS8 4
     20          

   \                                 In  segment DATA16_Z, align 1, align-sorted
   \   000000                REQUIRE ?cstart_init_zero
     21          char rx_data = 0;
   \                     rx_data:
   \   000000                DS8 1
     22          

   \                                 In  segment CODE, align 2
     23          void main(void)
   \                     main:
     24          {
     25            // Initialisierungen
     26            initMC();
   \   000000   ........     CALLA   #initMC
     27            initPWM(pwm_anzahl, pwm_on);
   \   000004   1D42....     MOV.W   &pwm_on, R13
   \   000008   1C42....     MOV.W   &pwm_anzahl, R12
   \   00000C   ........     CALLA   #initPWM
     28            initR2R();
   \   000010   ........     CALLA   #initR2R
     29            initSPI();
   \   000014   ........     CALLA   #initSPI
     30            initUART();
   \   000018   ........     CALLA   #initUART
   \   00001C   0343         NOP
     31            
     32            __bis_SR_register(GIE);     // Global Interrupt Enable
   \   00001E   32D2         BIS.W   #0x8, SR
   \   000020   053C         JMP     ??main_2
     33            
     34            while(1)
     35            {
     36              /*
     37              P4OUT |= BIT7;                      // Grüne LED leuchtet wenn das Programm bereit zum Starten ist
     38              P1OUT &= ~BIT0;                     // RoteLED aus
     39              while(0 == P1IFG);                  // Wenn S2 gedrückt wird, startet das Programm
     40              P1OUT |= BIT0;                      // Rote LED leuchtet wenn das Programm läuft
     41              P4OUT &= ~BIT7;                     // Grüne LED aus
     42              
     43              r2r_ansteuerung = 0;                // Zum Start alle "Bits" des R2R auf 0
     44              while(r2r_ansteuerung < r2r_aufloesung)                                      // Schleife steuert jede Biteinstellung des R2R-Netzwerkes an
     45              {
     46                P6OUT = r2r_ansteuerung;
     47                pwm_on = 0;
     48                while(pwm_on < pwm_anzahl)                                                // Schleife steuert jedes Pulsbreitenverhältniss an
     49                {
     50                  mittelwert = 0;
     51                  sum = 0;
     52                  conversioncounter = 0;
     53                  while(conversioncounter < mittelwert_anzahl)                            // Schleife bildet Mittelwert
     54                  {
     55                    // Wait for SPI Interrupts
     56                    sum = sum + SPI_recieve();    // Messung durch ADC
     57                  }
     58                  mittelwert = sum >> filter_aufloesung;          // Teilen der Summe durch 256
     59                  UART_send(mittelwert);                          // Über UART an PC
     60                  ++pwm_on;                                       // erhöht Pulsbreite und fungiert als counter
     61                }
     62                ++r2r_ansteuerung;
     63              }
     64          */ 
     65              UCB0TXBUF = 0xF;
     66              while((UCRXIFG & UCB0IFG) == 0);
     67              if(!rx_data == 0) 
     68              {
     69                P4OUT |= BIT7;                      
   \                     ??main_1:
   \   000022   F2D080002302 BIS.B   #0x80, &0x223
     70                P1OUT &= ~BIT0;
   \   000028   D2C30202     BIC.B   #0x1, &0x202
     71              } else 
   \                     ??main_2:
   \   00002C   F2400F00EE05 MOV.B   #0xf, &0x5ee
   \                     ??main_0:
   \   000032   D2B3FD05     BIT.B   #0x1, &0x5fd
   \   000036   FD2B         JNC     ??main_0
   \   000038   C293....     CMP.B   #0x0, &rx_data
   \   00003C   F223         JNE     ??main_1
     72              {
     73                P4OUT &= ~BIT7;                      
   \   00003E   F2C080002302 BIC.B   #0x80, &0x223
     74                P1OUT |= BIT0;
   \   000044   D2D30202     BIS.B   #0x1, &0x202
   \   000048   F13F         JMP     ??main_2
   \   00004A   0343         NOP
   \   00004C                REQUIRE UCB0TXBUF
   \   00004C                REQUIRE _A_UCB0ICTL_L
   \   00004C                REQUIRE _A_PBOUT_L
   \   00004C                REQUIRE _A_PAOUT_L
     75              }
     76            }
     77          }
     78          //++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     79          #pragma vector = USCI_B0_VECTOR

   \                                 In  segment ISR_CODE, align 2
     80          __interrupt void ISR_USCI_B0(void)
   \                     ISR_USCI_B0:
     81          {
     82            rx_data = UCB0RXBUF;                  // Auslesen löscht flag
   \   000000   D242EC05.... MOV.B   &0x5ec, &rx_data
     83          }
   \   000006   0013         RETI
   \   000008                REQUIRE UCB0RXBUF

   \                                 In  segment INTVEC, offset 0x6e, root
   \                     `??ISR_USCI_B0::??INTVEC 110`:
   \   00006E   ....         DC16    ISR_USCI_B0

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for pwm_anzahl>`:
   \   000000   0001         DC16 256

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for r2r_anzahl>`:
   \   000000   0001         DC16 256

   \                                 In  segment DATA16_ID, align 2, align-sorted
   \                     `?<Initializer for mittelwert_anzahl>`:
   \   000000   0001         DC16 256
     84            

   Maximum stack usage in bytes:

   CSTACK Function
   ------ --------
      4   ISR_USCI_B0
      4   main
        4   -> initMC
        4   -> initPWM
        4   -> initR2R
        4   -> initSPI
        4   -> initUART


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Initializer for mittelwert_anzahl>
       2  ?<Initializer for pwm_anzahl>
       2  ?<Initializer for r2r_anzahl>
       8  ISR_USCI_B0
       2  ISR_USCI_B0::??INTVEC 110
       1  UCB0RXBUF
       1  UCB0TXBUF
       2  _A_PAOUT_L
       2  _A_PBOUT_L
       2  _A_UCB0ICTL_L
       2  conversioncounter
      76  main
       2  mittelwert
       2  mittelwert_anzahl
       2  pwm_anzahl
       2  pwm_on
       2  r2r_ansteuerung
       2  r2r_anzahl
       1  rx_data
       4  sum

 
 76 bytes in segment CODE
  8 bytes in segment DATA16_AN
  6 bytes in segment DATA16_I
  6 bytes in segment DATA16_ID
 13 bytes in segment DATA16_Z
  2 bytes in segment INTVEC
  8 bytes in segment ISR_CODE
 
 84 bytes of CODE  memory
  6 bytes of CONST memory (+ 2 bytes shared)
 19 bytes of DATA  memory (+ 8 bytes shared)

Errors: none
Warnings: none
